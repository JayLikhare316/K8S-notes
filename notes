K8S

## 06 - 01 - 2025

## kubernetes architecture


# kubernetes architecture is based on the following components:
# - control plane: responsible for managing the cluster, including creating and deleting nodes, managing the network
# - worker nodes: run the actual containers and provide the resources needed to run the containers
# - etcd: a distributed key-value store that stores the cluster's state and configuration
# - api server: exposes the kubernetes api and handles requests from users and other components
# - controller manager: runs controllers that manage the cluster's state and enforce policies
# - scheduler: responsible for scheduling pods onto nodes based on resource availability and other factors
# - kube-proxy: a network proxy that provides network connectivity between pods and services
# - kubelet: runs on each node and is responsible for managing the node's resources and running and it shares all information to api server and also send health check to api server
# - cni : container network interface, provides network connectivity for containers
# - csi : container storage interface, provides storage for containers
# - csi driver : provides storage for containers
# - csi plugin : provides storage for containers
# - csi provisioner : provides storage for containers
# - csi attacher : provides storage for containers
# - csi resizer : provides storage for containers
# - csi snapshotter : provides storage for containers
# - container runtime: responsible for running containers on the node
# - network policies: define how pods can communicate with each other and with external services
# - persistent storage: provides persistent storage for data that needs to be retained across pod restarts
# - node: a machine that runs a kubernetes cluster (instance)
# - ingress: provides a way to expose services to the outside world
# - service: provides a way to access services from within the cluster
# - pod: the basic execution unit in kubernetes, a pod is a logical host for on(smallest unit of deployment) basically its docker containers
# - deployment: a way to manage the rollout of new versions of an application
# - replica set: ensures that a specified number of replicas of a pod are running at any giv
# - daemon set: ensures that a specified number of replicas of a pod are running at any giv
# - job: a way to run a batch of tasks and ensure that they are completed successfully
# - persistent volume claim: a way to request storage resources from the cluster
# - persistent volume: a way to provision storage resources from a pod
# - config map: a way to store and retrieve configuration data
# - secret: a way to store and retrieve sensitive data
# - service account: a way to authenticate and authorize pods to access cluster resources
# - cluster role: a way to define permissions for a cluster
# - cluster role binding: a way to bind a cluster role to a user or service account
# - namespace: a way to organize resources into logical groups
# - resource quota: a way to limit the amount of resources that a namespace can consume
# - pod security policy: a way to define security policies for pods
# - network policy: a way to define how pods can communicate with each other and with external services
# - storage class: a way to provision storage resources from a pod
# - cluster autoscaler: a way to automatically scale the cluster based on resource utilization
# - kubernetes dashboard: a web-based interface for managing the cluster
# - replication controller: a way to manage the rollout of new versions of an application
# - pod template: a way to define the configuration of a pod
# - pod affinity: a way to define the affinity of a pod to a node or other pods
# - cloud control manager: a way to manage the cluster's resources on a cloud provider
# - cloud provider: a way to manage the cluster's resources on a cloud provider
# - kubernetes cluster: a group of machines (nodes) that run containerized applications
# - kubernetes node: a machine that runs a kubernetes cluster (instance)
# - kubernetes pod: the basic execution unit in kubernetes, a pod is a logical host
# - kubernetes service: provides a way to access services from within the cluster


## K8S

Q.What is kubernetes?

- an open-source container orchestration system for automating the deployment, scaling, and management of container
- it was originally designed by google, and is now maintained by the cloud native computing foundation
- it allows for the deployment of applications and services in a scalable and highly available manner
- it provides a lot of features such as self-healing, load balancing, and resource management
- it is widely used in cloud computing and enterprise environments
- it is also used in edge computing and IoT environments
- it is a complex system that requires a lot of knowledge and expertise to use
- it is a multi-cloud platform that can run on multiple cloud providers such as AWS, GCP
- it is a hybrid cloud platform that can run on-premises and in the cloud

Q. Why do we need kubernetes and why it is used ?





Q.Architecture of kubernetes?

- it consists of a control plane and a data plane
- the control plane is responsible for managing the cluster and making decisions
- the data plane is responsible for running the applications and services
- the control plane consists of the following components:
- api server: responsible for exposing the kubernetes api
- controller manager: responsible for managing the state of the cluster
- scheduler: responsible for scheduling pods onto nodes
- etcd: responsible for storing the state of the cluster
- the data plane consists of the following components:

Q. What are nodes in k8s ?
- a node is a machine or a virtual machine that runs a pod[ec2 instances, VMs ,Containers]
- a node can be a physical machine or a virtual machine

Q. What is control plane?
- the control plane is the component of the kubernetes cluster that is responsible for managing the cluster and
making decisions
- it consists of the following components:
- api server
- controller manager
- scheduler
- etcd
- it is responsible for managing the state of the cluster and making decisions
- it is the brain of the kubernetes cluster
- it is responsible for scheduling pods onto nodes
- it is responsible for managing the lifecycle of pods
- it is responsible for managing the resources of the cluster
- it is responsible for managing the security of the cluster
- it is responsible for managing the networking of the cluster
- it is responsible for managing the storage of the cluster
- it is responsible for managing the monitoring of the cluster
- it is responsible for managing the logging of the cluster
- it is responsible for managing the alerting of the cluster
- it is responsible for managing the backup and restore of the cluster
- it is responsible for managing the upgrade and patching of the cluster
- it is responsible for managing the compliance of the cluster
- it is responsible for managing the governance of the cluster


Q.What are the pods?
- a pod is the basic execution unit in kubernetes
- a pod is a logical host for one or more containers
- a pod is a group of one or more containers that are run on a node and share resources

Q.Difference between kubelet and kubeproxy?

=========================================================================================================================================================================
| Aspect	        |                         Kubelet                                          |       Kube-proxy                                                         |
|-----------------|--------------------------------------------------------------------------|---------------------------------------------------------------------------
| Purpose	        | Manages containers and pods on a node.            	                     | Manages network rules and traffic routing for services.                  |
| Scope           | Node-level: Focuses on running containers and pods on a single node.	   | Network-level: Focuses on enabling communication between pods/services.  |
| Interaction	    | Works with the container runtime (e.g., Docker, containerd).	           | Works with network rules (e.g., IP tables, IPVS).                        |
| Responsibility	| Ensures containers are running as per PodSpecs.	                         | Ensures traffic is routed correctly to pods based on Service definitions.|
| Dependency	    | Directly interacts with the Kubernetes API server and container runtime. | Relies on the Kubernetes API server for Service and Endpoint updates.    |
=========================================================================================================================================================================




Kubernetes is an open-source platform designed to automate deploying, scaling, and managing containerized applications. It uses a **master-slave** (client-server) architecture, with a central control plane (Master Node) and worker nodes that run the containers. Here's an overview of its architecture:

### 1. **Master Node (Control Plane)**
   The master node is responsible for managing the Kubernetes cluster, making global decisions about the cluster (e.g., scheduling, maintaining the desired state of the cluster). It consists of the following key components:
   
   - **API Server (kube-apiserver)**:
     The API server is the central point for all communication within the cluster. It exposes the Kubernetes API, and all components interact with it to make requests. It validates and processes REST requests, allowing clients (like `kubectl`) or other components to query or modify cluster state.

   - **Controller Manager (kube-controller-manager)**:
     The controller manager runs controllers that regulate the state of the cluster. For example, it manages replication (ensuring that the correct number of pod replicas are running), deployments, and other controllers like node, namespace, and service controllers.

   - **Scheduler (kube-scheduler)**:
     The scheduler watches for newly created pods that have no assigned nodes and schedules them to run on the available worker nodes based on resource requirements, policies, and constraints.

   - **etcd**:
     `etcd` is a consistent, distributed key-value store that holds the cluster's configuration data, such as cluster state, API objects, and metadata. All other components access the `etcd` database for their configurations.

   - **Cloud Controller Manager**:
     It integrates with various cloud providers (like AWS, GCP, Azure) to manage cloud-specific resources such as load balancers, networking, and storage.

### 2. **Worker Nodes (Node)**
   The worker nodes are responsible for running the containers (in the form of Pods). Each worker node has the following components:

   - **Kubelet**:
     The kubelet is an agent running on each node, responsible for ensuring that containers are running in a Pod. It communicates with the API server and constantly reports the node status back to the control plane.

   - **Kube Proxy**:
     Kube proxy is responsible for maintaining network rules on each node. It enables network communication between pods, both within the cluster and to/from external services. Kube proxy ensures that traffic is routed to the correct pod when the service is accessed.

   - **Container Runtime**:
     The container runtime is the software responsible for running containers (e.g., Docker, containerd, or CRI-O). It pulls container images and runs the container instances inside the pod.

   - **Pods**:
     A Pod is the smallest deployable unit in Kubernetes and can contain one or more containers that share the same network namespace and storage volumes. The containers in a Pod communicate with each other via localhost and share resources like CPU, memory, and storage.

### 3. **Key Concepts of Kubernetes**

   - **Namespace**:
     Namespaces provide a way to divide cluster resources between multiple users or applications. It helps isolate resources in a multi-tenant environment.

   - **Services**:
     A service is an abstraction layer that defines a logical set of Pods and provides a stable endpoint (IP and DNS) for accessing them, regardless of the specific pod or node they are running on.

   - **ReplicaSets**:
     A ReplicaSet ensures that a specified number of replicas of a pod are running at any given time. It helps maintain the desired state of Pods.

   - **Deployments**:
     A deployment provides declarative updates to Pods and ReplicaSets, helping manage the rollout and rollback of application versions.

   - **ConfigMaps and Secrets**:
     ConfigMaps are used to store non-sensitive configuration data, and Secrets are used to store sensitive data like passwords and API keys.

### 4. **Communication in Kubernetes**
   - **Pod-to-Pod Communication**: Pods can communicate directly with each other across nodes via the pod IP address, thanks to the networking model provided by Kubernetes.
   - **Service Discovery**: Kubernetes provides DNS-based service discovery, meaning that services can be accessed by their service name instead of needing to know the pod's IP address.

### 5. **Kubernetes Components Summary**
   - **Master Node Components**:
     - API Server
     - Scheduler
     - Controller Manager
     - etcd (storage)
     - Cloud Controller Manager (optional)
   - **Worker Node Components**:
     - Kubelet
     - Kube Proxy
     - Container Runtime
     - Pods

This architecture allows Kubernetes to scale applications and services dynamically, ensuring high availability and reliability across a containerized infrastructure.




##07-01-2025

##kubernetes cluster create

##kubectl 
##eksctl
##aws

##things to learn

pod 
replicaset 
deployment 
services 
 load balancers 
 node port 
 cluster ip
 config 
 secrets 
 cmp 
namespace
resource replca 
request quata 
ingres 
volumes 
HPD 


## how to create a kubernetes cluster 

## install kubectl
   curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl"

echo "$(cat kubectl.sha256)  kubectl" | sha256sum --check

sudo install -o root -g root -m 0755 kubectl /usr/local/bin/kubectl


##pod.yaml


apiVersion: v1
kind: Pod
metadata:
  name: nginx
spec:
  containers:
  - name: nginx
    image: nginx
    ports:
      - containerPort: 80



kubectl get nodes    --- to get information about created clusters 

kubectl get pods     --- to get information about created pods

client version can be only -1 oe -2 by kubernetes version

##task 
set permanent alias in linux 

##task
perform/implement lamp server

##Deployment and replica

##Replica Set (RS)

Replica Set is a resource in Kubernetes that ensures a specified number of replicas (i.e., copies of a pod) are running at any given time. It is a type of controller that automatically manages
the number of replicas of a pod to maintain the desired state.
Replica Set is used to ensure that a specified number of replicas of a pod are running at any
given time.
Replica Set is a type of controller that automatically manages the number of replicas of a pod to
maintain the desired state.

node<Deployment<Replicaset<pods


#imperative /declrative 
#commands / manifest

##to get inside the pod 
kubectl exec -it (podname) -- bash


## to excute commands inside a container in a pod
kubectl exec -it (podname) -c (container-name) -- (command)

ex... kubectl exec -it pod3 -c firstcontainer -- ls -ltr /etc --> It will list file in etc directory 


##what is ReplicaSet



##Replica set Has 3 Components
1. Selector : pod ko select karna 
2. Replicas  : kitne pods chalne chahiye 
3. Template : kaise ek naya pod create karna hain 

##ReplicaSet Lifecycle
1. create : run manifest file
2. Scale : replica KITNA scale karna hain
3. Managed : replica set pod ko monitor arta hain agr koi pod bnd hua to hain dusra pod create karta hain

use case :
1. high availability
2. load balancing in robin round manner

##REPLICA set manifest demo

apiVersion: apps/v1
kind: ReplicaSet
metadata: 
  name: nginx-replicas
  labels: 
    app: nginx-repl
spec:
  replicas: 3
  selector:
    matchLabels:
      app: nginx-repl        ##----> ye check karenga pod ke labeles ko aur use me replicaset chalayenga
  template:
    metadata: 
      labeles:
        app: nginx-repl
    spec:
      containers:
      - name: nginx       ##(container 1 name given)
        image: nginx:1.14.2
        ports:
        - containerPort: 80



## to list pods in detailed manner with pod ip and labels

kubectl get pods -o wide --show-labels

## to list replicasets 

kubectl get replicasets -o wide --show-labels



##What is Node Selector ?

iska use ye hain ki node pe jake run hona hain manually

##components
1. nodeSelector
2. nodetype

##node selector manifest demo

apiVersion: v1
kind: Pod
metadata: 
  name: pod1
  labels: 
    app: nginx
spec:
  containers: 
  - name: myfirstcontainer
    image: nginx:1.23
  nodeSelector:              ##----> ye node select krta hain 
    nodetype: "prodcution"       ##----> ye node type hain jo hum select kr rhe hain


##to give labels to node
kubectl label nodes <node-name> <label-name>=<label-value> 

kubectl label nodes node1 nodetype=production





## what is Deployment ?
  

  deployment decide karta hain ki kis pod ko run karna hain aur kaise 
  replicas decide karta hain kitne copies hone chahiye
  update strategy deployment allow krta hain ki kaise hum updates apply krenge 

deployment jab run karte hain tb bydefault hamesha 4 chize create krta hain pod , service ,deployment, replicaset

##benefits of deployment /advantaeges 

1. zero Down time.
2. Rollback
3. Scalability

##TO create deployment

kubectl create deployment (name-of-deployment-to-give) --replicas=(no.of replicas)  --image=(image-name):(version)

kubectl create deployment mynginx --replicas=3  --image=nginx:latest 


##TO get deployment details
kubectl get deployment -o wide --show-labels

## to describe specific deployment 

kubectl describe deployment <deployment-name>


###Deployment Using YAML file

apiVersion: apps/v1
kind: Deployment
metadata:
  name: nginx-deployment
  labels:
    app: nginx
spec:
  replicas: 3
  selector:
    matchLabels:
      app: nginx 
  template:
    metadata:
      labels:
        app: nginx
    spec:
      containers:
      - name: nginx
        image: nginx:1.14.2
        ports:
        - containerPort: 80




## What is Rolling Out Feature ?

##Demo manifest file for rolling update  VERSION 1 FILE

apiVersion: apps/v1
kind: Deployment
  metadata:
    name: apache-deployment
    labels :
      app: apache
    annotations:                             ##Its means Tags 
      kubernetes.io/change-cause: "Version 1"
spec :
  replicas: 6
  minReadySeconds: 20               ##kitne second baad dusra pod launch hona chahiye
  strategy:
    rollingUpdate:
      maxSurge: 2
      maxUnavailable: 0
    type: rollingUpdate
  selector:
    matchLabels:
      app: apache
  template:
    metadata:
      labels:
        app: apache
    spec:
      containers:
      - name: apache 
        image: docker9447/apache:v1
        ports:
        - containerPort: 80


## Rolling Update Feature Demo VERSION 2 FILE


apiVersion: apps/v1
kind: Deployment
  metadata:
    name: apache-deployment
    labels :
      app: apache
    annotations:                             ##Its means Tags 
      kubernetes.io/change-cause: "Version 2"
spec :
  replicas: 6
  minReadySeconds: 20               ##kitne second baad dusra pod launch hona chahiye
  strategy:
    rollingUpdate:
      maxSurge: 2
      maxUnavailable: 0
    type: rollingUpdate
  selector:
    matchLabels:
      app: apache
  template:
    metadata:
      labels:
        app: apache
    spec:
      containers:
      - name: apache 
        image: docker9447/apache:v2
        ports:
        - containerPort: 80


##to check rollout history of deployment

kubectl rollout history deployment apache-deployment

##TO rollback to previous version

kubectl rollout undo --to-revision=1 deployment apache-deployment

##to check status of rollout

kubectl rollout status deployment apache-deployment


## What is Recreate strategy ?
 ye pods ko replace karne ka tarika batata self-healing


#Recreate Strategy DEMO YAML File 

apiVersion: apps/v1
kind: Deployment
  metadata:
    name: apache-deployment
    labels :
      app: apache
    annotations:                             ##Its means Tags 
      kubernetes.io/change-cause: "Version 1"
spec :
  replicas: 6
  minReadySeconds: 20               ##kitne second baad dusra pod launch hona chahiye
  strategy:
    type: Recreate
  selector:
    matchLabels:
      app: apache
  template:
    metadata:
      labels:
        app: apache
    spec:
      containers:
      - name: apache 
        image: docker9447/apache:v1
        ports:
        - containerPort: 80

## Components 
1. pod template
2. rolling update



### SECRET and CONFIGMAP

##configmap

non confindential files sent

##CONFIGMAP YAML DEMO

kubectl create cm name=nginx-cm --from-file=index.html                     ##cm-configmap

kubectl create cm name=nginx-cm --from-file=index.html --dry-run=client -o yaml > configmap.yaml

apiVersion:
kind: ConfigMap
metadata:
  

##secret

sensative confidential data sent

##SECRET YAML DEMO

kubectl create secret generic itsmysecret --from-literal=idli=chutney --dry-run=client -o yaml > secret.yaml


kubectl port-forward svc/nginx-service 80:80 


kubectl port-forward pod/mypod :80 


echo "wejhkghj" | base64 --decode


kubectl expose pod nginx-secret --port=80  -o yaml --dry-run=client > expose.yaml

##What is DaemonSet ?

# A DaemonSet in Kubernetes is a feature that ensures a pod runs on all or some nodes in a cluster: 
# How it works
# When a new node joins the cluster, a DaemonSet automatically adds a pod to it. When a node is removed, the pod is removed. 
# What it's used for
# DaemonSets are used to deploy background services, such as: 
# Monitoring systems 
# Log collection agents 
# Storage volumes 
# Networking helpers, like load balancers, network proxies, or VPN clients 

# DaemonSets are also used to deploy services that need to run on every node in the cluster,
# such as:
# Node-level monitoring tools
# Node-level logging tools
# Node-level backup tools

## What is resource request and resource limit ?

##Resource Request
# The resource request is the amount of resources that a container needs to run. It is used to
# ensure that the container has enough resources to run without being throttled or terminated.
# The resource request is specified in the container's resource request section of the pod's
# configuration file.
# For example, if a container needs 1 CPU core and 512 MB of memory, th
# resource request would be specified as follows:
# resources:
#   requests:
#     cpu: 1
#     memory: 512Mi


resource request ek tara se configuration hain jo hum pods ke liye define krte hain jisse kubernetes ko pta chalta hain ki kitne resources chahiye
ye resources CPU memomry ke form me define kiye jaate hain 

##What is Resource Limit ?
A "resource limit" refers to the maximum amount of a specific resource (like CPU, memory, or storage) that a system, application, or user is allowed to consume, essentially acting as a cap to prevent over-usage and ensure fair distribution of resources across multiple users or processes on a system

resurce limit configuration hain jo pods ki maximum resource limit define krta hain 


# Resource Limit
# The resource limit is the maximum amount of resources that a container can use. It is used to
# prevent a container from consuming too many resources and causing the node to run out of resources.
# The resource limit is specified in the container's resource limit section of the pod's
# configuration file.
# For example, if a container is limited to 2 CPU cores and 1 GB of memory
# the resource limit would be specified as follows:
# resources:
#   limits:
#     cpu: 2
#     memory: 1Gi


apiVersion: v1
kind: Pod 
metadata: 
  name: pod1 
  labels: 
    env: prod 
spec: 
  containers: 
  - name: myfirstcontainer
    image: nginx:latest 
    resources: 
      requests: 
        memory: "1Gi"
        CPU: "800m"


## Services in Kubernetes

## 1. What is ClusterIp ?

kubectl expose pod (podname) --port=8080 --target-port=80 --name (newservicename)    ###creating new service with name and port number

kubectl get svc          ## to check running services

kubectl get svc -o wide  ## to check running services with more details

## With YAMl FILE 

apiVersion: apps/v1
kind: Deployment 
metadata: 
  name: nginx-deployment 
  labels: 
    app: nginx
spec: 
  replicas: 3
  selector:
    matchLabels: 
      app: nginx 
  template: 
    metadta: 
      labels: 
        app: nginx
    spec:
      containers:
      - name: nginx
        image: nginx:latest
        ports:
        - containerPort: 80


---

apiVersion: v1 
kind: Service 
metadata: 
  name: nginx-service 
spec: 
  selector: 
    app: nginx 
  ports:
  - protocol: TCP 
    port: 8080 
    targetport: 80

## 2. NodePort 

kubectl expose pod (podname) --port=8080 --target-port=80 --type NodePort --name=NP-service #(new-servicename)

kubectl get endpoints 

##YAML File

apiVersion: v1 
kind: Service 
metadata: 
  name: nginx-service 
spec: 
  type: NodePort
  selector: 
    app: nginx 
  ports:
  - port: 8080 
    targetport: 80
    nodePort: 31254      ##Default range 30000-32767



## 3. Load Balancer 


## what is Namespace ?

 logical partition hain kubernetes mein jo cluster resources ko isolate aur organize krta hain ye multiple teams ya projects virtual cluster provide karte hain.
 resources ko alag alag devide kr skte hain 


##this is used in realtime companies 
dev for development
sit for system integration testing
uat for user acceptance testing
prod for production

Example Workflow in Kubernetes:

• Dev Namespace: Developers push changes to this namespace for initial testing.
• SIT Namespace: After initial testing, changes are moved to this namespace for integration testing, 
where different components are validated together.
• UAT Namespace: Once integration testing is successful, the application moves to the UAT namespace, 
where users validate whether the application meets their requirements.
• Prod Namespace: After UAT approval, the application is deployed to the production namespace for actual 
use by end-users.

 kubectl get ns    ## to list namespace 

 kubectl create ns (name-of-namespace)

apiVersion: v1 
kind: pod 
metadata: 
  name: pod1 
  namespace: sit
  labels: 
    env: sit
spec: 
  containers: 
  - name: mycontainer 
    image: nginx:latest 


kubectl get pods -n sit   ##-n= namespace else --namespace

apiVersion: v1 
kind: Service 
metadata: 
  name: nginx-service 
spec: 
  selector: 
    app: sit       #(given-env-variable)
  ports:
  - protocol: TCP
    port: 8080 
    targetport: 80

kubectl create -f (uper-YAML-file-name) --namespace sit

kubectl get svc -n sit


